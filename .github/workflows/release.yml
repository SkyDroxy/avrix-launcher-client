name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.4.2 or v0.4.2)'
        required: true
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-latest
    env:
      AVRIX_UPDATER_ENDPOINT: 'https://s3.storage.skymunt.com/avrix-launcher/latest.json'
      AVRIX_UPDATER_PUBKEY: 'dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1YmxpYyBrZXk6IEQ0MDZEQzhEREQwQkEwNUMKUldSY29BdmRqZHdHMUVaR1ZFZWY3ZWJ6NnZ3T3Q5SU1GRGRXSVVOLzAxVGVtMTR4c1lyYmhGeEQK'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install Windows bundler dependencies (NSIS & WiX)
        if: runner.os == 'Windows'
        run: |
          choco install nsis -y
          choco install wixtoolset -y
          choco install innosetup -y

      - name: Install Tauri CLI
        run: pnpm add -D @tauri-apps/cli

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Set default NEW_VERSION from package.json
        run: |
          $ver = node -e "console.log(require('./package.json').version)"
          echo "NEW_VERSION=$ver" >> $env:GITHUB_ENV

      - name: Bump version from input (manual dispatch)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          node scripts/bump-version.cjs ${{ inputs.version }}
          $ver = node -e "console.log(require('./package.json').version)"
          echo "NEW_VERSION=$ver" >> $env:GITHUB_ENV

      - name: Derive version from tag (push tag)
        if: ${{ github.event_name == 'push' }}
        run: |
          $tag = "${{ github.ref_name }}" # e.g., v0.4.2
          $ver = $tag.TrimStart('v')
          node scripts/bump-version.cjs $ver
          echo "NEW_VERSION=$ver" >> $env:GITHUB_ENV

      - name: Create Git tag (manual dispatch)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git commit -am "chore: release v$env:NEW_VERSION" || echo "No changes to commit"
          git tag v$env:NEW_VERSION
          git push origin HEAD:main --follow-tags

      - name: Ensure GitHub Release exists
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          $repo = "${{ github.repository }}"
          $tag = "v$env:NEW_VERSION"
          $headers = @{ Authorization = "Bearer $env:GITHUB_TOKEN"; 'User-Agent' = 'gh-actions'; Accept = 'application/vnd.github+json' }
          try {
            $resp = Invoke-RestMethod -Method GET -Uri "https://api.github.com/repos/$repo/releases/tags/$tag" -Headers $headers
            $id = $resp.id
          } catch {
            $payload = @{ tag_name = $tag; name = "Avrix Launcher $tag"; body = "Auto-generated release for $tag"; draft = $false; prerelease = $false } | ConvertTo-Json
            $create = Invoke-RestMethod -Method POST -Uri "https://api.github.com/repos/$repo/releases" -Headers $headers -Body $payload
            $id = $create.id
          }
          if (-not $id) { throw "Failed to determine release id" }
          echo "RELEASE_ID=$id" >> $env:GITHUB_ENV

      - name: Build and Publish Release (Tauri Action)
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          args: --bundles nsis
          releaseId: ${{ env.RELEASE_ID }}

      - name: Copy launcher EXE for Updater
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          node scripts/copy-exe.cjs
          if (-not (Test-Path "installer/payload/build/AvrixLauncher.exe")) { throw "AvrixLauncher.exe not found in installer/payload/build" }

      - name: Compile Inno Setup Updater
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $iscc = 'C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe'
          if (-not (Test-Path $iscc)) { throw "Inno Setup compiler not found at $iscc" }
          # Build updater.iss (expects NEW_VERSION via GetEnv("NEW_VERSION"))
          & "$iscc" "installer\\updater.iss"
          $ver = "$env:NEW_VERSION"
          # Compute expected output based on updater.iss (OutputDir=Output, OutputBaseFilename=Avrix-Update-{#AppVersion})
          $outDir = (Resolve-Path "installer/Output").Path
          $expectedName = "Avrix-Update-$ver.exe"
          $expectedPath = Join-Path -Path $outDir -ChildPath $expectedName
          if (-not (Test-Path $expectedPath)) {
            Write-Host "Updater expected at: $expectedPath"
            Write-Host "Listing installer/Output for diagnostics:"
            Get-ChildItem -Path $outDir -Filter *.exe | Select-Object FullName, Length, LastWriteTime | Format-Table | Out-String | Write-Host
            throw "Updater executable not found after compilation"
          }

          $targetName = "Avrix Launcher-Updater-$ver.exe"
          $targetPath = Join-Path -Path $outDir -ChildPath $targetName
          # Ensure directory exists
          $null = New-Item -ItemType Directory -Force -Path (Split-Path -Path $targetPath)
          # Move/rename to the desired name
          Move-Item -Force -Path $expectedPath -Destination $targetPath

          echo "UPDATER_EXE_PATH=$targetPath" >> $env:GITHUB_ENV

      - name: Sign Updater executable
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          $ErrorActionPreference = 'Stop'
          if (-not $env:UPDATER_EXE_PATH) { throw "UPDATER_EXE_PATH not set" }
          $sigOut = "$env:UPDATER_EXE_PATH.sig"
          # Use Tauri signer to create a minisign-formatted signature and write it as-is
          $raw = pnpm --silent tauri signer sign --private-key "$env:TAURI_SIGNING_PRIVATE_KEY" --password "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$env:UPDATER_EXE_PATH"
          if ($LASTEXITCODE -ne 0 -or -not $raw) {
            Write-Host "tauri signer failed with exit code $LASTEXITCODE"
            throw "Failed to obtain signature from tauri signer"
          }
          # Keep only minisign-valid lines: comments and base64 blocks. Drop any instruction text.
          $lines = $raw -split "\r?\n"
          $filtered = $lines | Where-Object { $_ -and ($_ -match '^(untrusted comment:|trusted comment:|[A-Za-z0-9+/=]+)$') }
          if (-not $filtered -or -not ($filtered | Where-Object { $_ -like 'untrusted comment:*' })) {
            Write-Host "Unexpected signature output:"; Write-Host ($raw | Out-String)
            throw "Unexpected signature format from tauri signer"
          }
          $sig = ($filtered -join "`n")
          Set-Content -Path $sigOut -Value $sig -Encoding ASCII
          echo "UPDATER_SIG_PATH=$sigOut" >> $env:GITHUB_ENV

      - name: Prepare latest.json for S3
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $ver = "$env:NEW_VERSION"

          # Use the Inno Setup Updater executable and its signature
          if (-not $env:UPDATER_EXE_PATH) { throw "UPDATER_EXE_PATH not set" }
          if (-not (Test-Path $env:UPDATER_EXE_PATH)) { throw "Updater executable not found at $env:UPDATER_EXE_PATH" }
          if (-not $env:UPDATER_SIG_PATH) { throw "UPDATER_SIG_PATH not set" }
          if (-not (Test-Path $env:UPDATER_SIG_PATH)) { throw "Updater signature not found at $env:UPDATER_SIG_PATH" }

          $installer = Get-Item -Path "$env:UPDATER_EXE_PATH"
          $sigPath   = "$env:UPDATER_SIG_PATH"

          $sig = (Get-Content $sigPath -Raw).Trim()
          $pubDate = (Get-Date).ToUniversalTime().ToString('yyyy-MM-ddTHH:mm:ssZ')
          $assetName = $installer.Name

          $jsonObj = [ordered]@{
            version   = $ver
            notes     = ""
            pub_date  = $pubDate
            platforms = [ordered]@{
              "windows-x86_64" = [ordered]@{
                signature = $sig
                url       = "https://s3.storage.skymunt.com/avrix-launcher/v$ver/$assetName"
              }
            }
          }
          $json = $jsonObj | ConvertTo-Json -Depth 5
          Set-Content -Path latest.json -Value $json -Encoding UTF8

          # Expose paths for subsequent step
          echo "INSTALLER_PATH=$($installer.FullName)" >> $env:GITHUB_ENV
          echo "LATEST_JSON_PATH=$((Resolve-Path latest.json).Path)" >> $env:GITHUB_ENV
          echo "SIG_PATH=$sigPath" >> $env:GITHUB_ENV

      - name: Upload artifacts to MinIO (S3)
        shell: pwsh
        env:
          MINIO_ENDPOINT: ${{ secrets.MINIO_ENDPOINT }}
          MINIO_ACCESS_KEY: ${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY: ${{ secrets.MINIO_SECRET_KEY }}
        run: |
          $ErrorActionPreference = 'Stop'
          $mc = "$PWD/mc.exe"
          Invoke-WebRequest -Uri "https://dl.min.io/client/mc/release/windows-amd64/mc.exe" -OutFile $mc

          & $mc alias set s3 $env:MINIO_ENDPOINT $env:MINIO_ACCESS_KEY $env:MINIO_SECRET_KEY

          # Ensure bucket exists and is public-read
          try { & $mc mb -p s3/avrix-launcher } catch { }
          & $mc anonymous set download s3/avrix-launcher

          $ver = "$env:NEW_VERSION"
          $dest = "s3/avrix-launcher/v$ver/"
          & $mc cp "$env:INSTALLER_PATH" $dest
          & $mc cp "$env:SIG_PATH" $dest

          # Publish latest.json at bucket root
          & $mc cp "$env:LATEST_JSON_PATH" "s3/avrix-launcher/latest.json"

      - name: Copy launcher EXE for Inno Setup
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          node scripts/copy-exe.cjs
          if (-not (Test-Path "installer/payload/build/AvrixLauncher.exe")) { throw "AvrixLauncher.exe not found in installer/payload/build" }

      - name: Compile legacy Inno Setup installer
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $iscc = 'C:\Program Files (x86)\Inno Setup 6\ISCC.exe'
          if (-not (Test-Path $iscc)) { throw "Inno Setup compiler not found at $iscc" }
          # NEW_VERSION is already set in env; setup.iss reads it via GetEnv("NEW_VERSION")
          & "$iscc" "installer\setup.iss"
          $ver = "$env:NEW_VERSION"
          # Try to find the output installer
          $pattern = "*Setup-$ver*.exe"
          $found = Get-ChildItem -Recurse -Path installer -Filter $pattern | Select-Object -First 1
          if (-not $found) { $found = Get-ChildItem -Recurse -Path . -Filter $pattern | Select-Object -First 1 }
          if (-not $found) { throw "Inno installer not found with pattern $pattern" }
          echo "INNO_EXE_PATH=$($found.FullName)" >> $env:GITHUB_ENV

      - name: Upload Inno installer to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.NEW_VERSION }}
          files: |
            ${{ env.INNO_EXE_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload Inno installer to MinIO (S3)
        if: env.INNO_EXE_PATH != ''
        shell: pwsh
        env:
          MINIO_ENDPOINT: ${{ secrets.MINIO_ENDPOINT }}
          MINIO_ACCESS_KEY: ${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY: ${{ secrets.MINIO_SECRET_KEY }}
        run: |
          $ErrorActionPreference = 'Stop'
          $mc = "$PWD/mc.exe"
          if (-not (Test-Path $mc)) { Invoke-WebRequest -Uri "https://dl.min.io/client/mc/release/windows-amd64/mc.exe" -OutFile $mc }
          & $mc alias set s3 $env:MINIO_ENDPOINT $env:MINIO_ACCESS_KEY $env:MINIO_SECRET_KEY
          $ver = "$env:NEW_VERSION"
          $dest = "s3/avrix-launcher/v$ver/"
          & $mc cp "$env:INNO_EXE_PATH" $dest
